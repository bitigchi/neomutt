From 194a60ae0ec6f0f09d5e40023894363288df532e Mon Sep 17 00:00:00 2001
From: Richard Russon <rich@flatcap.org>
Date: Thu, 14 May 2020 12:01:21 -0700
Subject: Adjust message-id extraction to retry more permissively on failure

It turns out some illegal message-id headers have neither angle
brackets nor even an '@' in them.  So adopt a different approach.

First try parsing the Message-ID header in a strict(ish) mode
requiring angle brackets.  If that returns nothing, then try again in
loose mode, which will basically grab the first non-comment token.

Change References and In-Reply-To to keep the strict(ish) mode.  We
might loose some parent references, but that won't cause much loss of
functionality in Mutt, and also helps prevents parsing in "garbage"
and passing that back in replies.

Thanks to Oswald Buddenhagen for the suggested approach.

Upstream-commit: https://gitlab.com/muttmua/mutt/commit/194a60ae0ec6f0f09d5e40023894363288df532e

Co-authored-by: Kevin McCarthy <kevin@8t8.us>
---
 parse.c  | 41 +++++++++++++++++++++--------------------
 protos.h |  2 +-
 send.c   |  2 +-
 3 files changed, 23 insertions(+), 22 deletions(-)

diff --git a/parse.c b/parse.c
index e0b0c800..9512ef94 100644
--- a/parse.c
+++ b/parse.c
@@ -104,7 +104,7 @@ static LIST *mutt_parse_references (char *s, int in_reply_to)
   char *m;
   const char *sp;
 
-  m = mutt_extract_message_id (s, &sp);
+  m = mutt_extract_message_id (s, &sp, 0);
   while (m)
   {
     t = safe_malloc (sizeof (LIST));
@@ -112,7 +112,7 @@ static LIST *mutt_parse_references (char *s, int in_reply_to)
     t->next = lst;
     lst = t;
 
-    m = mutt_extract_message_id (NULL, &sp);
+    m = mutt_extract_message_id (NULL, &sp, 0);
   }
 
   return lst;
@@ -1012,12 +1012,17 @@ time_t mutt_parse_date (const char *s, HEADER *h)
 
 /* extract the first substring that looks like a message-id.
  * call back with NULL for more (like strtok).
+ *
+ * allow_nb ("allow nonbracketed"), if set, extracts tokens without
+ * angle brackets.  This is a fallback to try and get something from
+ * illegal message-id headers.  The token returned will be surrounded
+ * by angle brackets.
  */
-char *mutt_extract_message_id (const char *s, const char **saveptr)
+char *mutt_extract_message_id (const char *s, const char **saveptr, int allow_nb)
 {
   BUFFER *message_id = NULL;
   char *retval;
-  int in_brackets = 0, has_atsign = 0;
+  int in_brackets = 0;
   size_t tmp;
 
   if (!s && saveptr)
@@ -1044,7 +1049,6 @@ char *mutt_extract_message_id (const char *s, const char **saveptr)
         goto success;
       }
       mutt_buffer_clear (message_id);
-      has_atsign = 0;
     }
     else if (*s == '(')
     {
@@ -1054,28 +1058,23 @@ char *mutt_extract_message_id (const char *s, const char **saveptr)
     }
     else if (*s == ' ' || *s == '\t')
     {
-      if (!in_brackets && mutt_buffer_len (message_id))
-      {
-        if (has_atsign)
-          break;
-        mutt_buffer_clear (message_id);
-      }
+      if (!in_brackets && allow_nb && mutt_buffer_len (message_id))
+        break;
     }
     else
     {
-      if (!in_brackets && !mutt_buffer_len (message_id))
-        mutt_buffer_addch (message_id, '<');
-      if (*s == '@')
-        has_atsign = 1;
-      mutt_buffer_addch (message_id, *s);
+      if (in_brackets || allow_nb)
+      {
+        if (allow_nb && !mutt_buffer_len (message_id))
+          mutt_buffer_addch (message_id, '<');
+        mutt_buffer_addch (message_id, *s);
+      }
     }
 
     s++;
   }
 
-  /* be a little stricter for ids outside of brackets.
-   * at least insist they have an '@' in them */
-  if (!in_brackets && has_atsign && mutt_buffer_len (message_id))
+  if (!in_brackets && allow_nb && mutt_buffer_len (message_id))
     mutt_buffer_addch (message_id, '>');
   else
     mutt_buffer_clear (message_id);
@@ -1331,7 +1330,9 @@ int mutt_parse_rfc822_line (ENVELOPE *e, HEADER *hdr, char *line, char *p, short
       {
         /* We add a new "Message-ID:" when building a message */
         FREE (&e->message_id);
-        e->message_id = mutt_extract_message_id (p, NULL);
+        e->message_id = mutt_extract_message_id (p, NULL, 0);
+        if (!e->message_id)
+          e->message_id = mutt_extract_message_id (p, NULL, 1);
         matched = 1;
       }
       else if (!ascii_strncasecmp (line + 1, "ail-", 4))
diff --git a/protos.h b/protos.h
index ed3e7a2c..c8080431 100644
--- a/protos.h
+++ b/protos.h
@@ -80,7 +80,7 @@ void set_quadoption (int, int);
 int query_quadoption (int, const char *);
 int quadoption (int);
 
-char* mutt_extract_message_id (const char *, const char **);
+char* mutt_extract_message_id (const char *, const char **, int);
 
 ADDRESS *mutt_get_address (ENVELOPE *, char **);
 ADDRESS *mutt_lookup_alias (const char *s);
diff --git a/send.c b/send.c
index 75d74195..d20bf180 100644
--- a/send.c
+++ b/send.c
@@ -309,7 +309,7 @@ static void process_user_header (ENVELOPE *env)
     }
     else if (ascii_strncasecmp ("message-id:", uh->data, 11) == 0)
     {
-      char *tmp = mutt_extract_message_id (uh->data + 11, NULL);
+      char *tmp = mutt_extract_message_id (uh->data + 11, NULL, 0);
       if (rfc822_valid_msgid (tmp) >= 0)
       {
 	FREE(&env->message_id);
-- 
2.26.2

